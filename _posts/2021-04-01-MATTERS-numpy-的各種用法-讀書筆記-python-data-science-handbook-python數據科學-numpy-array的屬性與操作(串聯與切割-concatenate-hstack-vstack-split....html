---
layout: post
title: NumPy 的各種用法 - 讀書筆記 - Python Data Science Handbook - Python數據科學 - NumPy Array的屬性與操作(串聯與切割
  - Concatenate、hstack、vstack、split...
date: 2021-04-01 13:05:58.000000000 +00:00
link: https://matters.news/@CHWang/num-py-%25E7%259A%2584%25E5%2590%2584%25E7%25A8%25AE%25E7%2594%25A8%25E6%25B3%2595-%25E8%25AE%2580%25E6%259B%25B8%25E7%25AD%2586%25E8%25A8%2598-python-data-science-handbook-python%25E6%2595%25B8%25E6%2593%259A%25E7%25A7%2591%25E5%25AD%25B8-num-py-array%25E7%259A%2584%25E5%25B1%25AC%25E6%2580%25A7%25E8%2588%2587%25E6%2593%258D%25E4%25BD%259C-%25E4%25B8%25B2%25E8%2581%25AF%25E8%2588%2587%25E5%2588%2587%25E5%2589%25B2-concatenate-hstack-vstack-split-vsplit-hsplit-num-py-array%25E7%259A%2584%25E5%2590%2584%25E7%25A8%25AE%25E8%25A8%2588%25E7%25AE%2597%25E6%2596%25B9%25E6%25B3%2595-u-funcs-5-bafyreihyjnhkrbpje62zq5l7mvhmkrflqkfbtmty4pyi3xuug43cmy7pje
categories: matters
tags: blog
author: 為自己Coding
---

<h2><a href="https://github.com/chwang12341/Book/blob/master/Python-Data-Science-Handbook-Personal-Note/NumPy/NumPy%E7%9A%84%E5%90%84%E7%A8%AE%E7%94%A8%E6%B3%95.md" target="_blank">Github連結</a></h2><figure class="image">
      <picture>
        <source type="image/webp" media="(min-width: 768px)" srcset="https://assets.matters.news/processed/1080w/embed/33d31086-1b38-4532-951f-346620901989.webp" onerror="this.srcset='https://assets.matters.news/embed/33d31086-1b38-4532-951f-346620901989.jpeg'">

        <source media="(min-width: 768px)" srcset="https://assets.matters.news/processed/1080w/embed/33d31086-1b38-4532-951f-346620901989.jpeg" onerror="this.srcset='https://assets.matters.news/embed/33d31086-1b38-4532-951f-346620901989.jpeg'">

        <source type="image/webp" srcset="https://assets.matters.news/processed/540w/embed/33d31086-1b38-4532-951f-346620901989.webp">

        <img src="https://assets.matters.news/embed/33d31086-1b38-4532-951f-346620901989.jpeg" srcset="https://assets.matters.news/processed/540w/embed/33d31086-1b38-4532-951f-346620901989.jpeg" loading="lazy" referrerpolicy="no-referrer">
      </picture>
    <figcaption><span>攝影師：Markus Spiske，連結：Pexels</span></figcaption></figure><p><br></p><p><br></p><h2><strong>2.2章 NumPy數組基礎</strong></h2><p><br></p><h2><strong>1. 重要觀念:</strong></h2><ul><li>Python中的數據處理幾乎與NumPy Array操作是同義詞</li><li>Pandas也是由NumPy数组構建的</li></ul><h3><br></h3><h3><br></h3><h2><strong>2. NumPy數組操作的基本種類:</strong></h2><ul><li>數的屬性:決定數組的大小、形狀、內存占用量、數據類型</li><li>數組的索引:獲取與設定個別數組元素的值</li><li>數組的切片:獲取與設定數組中的子數組</li><li>數組的變形:  改變數组的形狀</li><li>組合與切分數組多: 將多個個數组合成一個數組，將一個數組切成多個數組</li></ul><h3><br></h3><h3><br></h3><h2><strong>3. NumPy數組的屬性(Attributes)</strong></h2><p><br></p><h4><strong>創建一維、二維、三維數組</strong></h4><pre class="ql-syntax">import numpy as np
​
## 設定隨機數種子,目的是設定一樣的話,隨機出來的數字组合才會一樣
​
np.random.seed(1)
​
## 創建一维、二维、三維的數組,並用隨機產生器生成數據
d1 = np.random.randint(10, size = 10)
​
d2 = np.random.randint(10, size = (5,5))
​
d3 = np.random.randint(10, size = (2,4,6))
​
​
print(d1)
print(d2)
print(d3)
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[5 8 9 5 0 0 1 7 6 9]
[[2 4 5 2 4]
 [2 4 7 7 9]
 [1 7 0 6 9]
 [9 7 6 9 1]
 [0 1 8 8 3]]
[[[9 8 7 3 6 5]
 [1 9 3 4 8 1]
 [4 0 3 9 2 0]
 [4 9 2 7 7 9]]
​
 [[8 6 9 3 7 7]
 [4 5 9 3 6 8]
 [0 2 7 7 9 7]
 [3 0 8 7 7 1]]]
</pre><h4><br></h4><h4><strong>ndim、shape、size、dtype用法</strong></h4><ul><li>dim: 數組的維度</li><li>shape: 每個維度的大小</li><li>size: 數組的大小(長度)</li><li>dtype:數據類型</li><li>itemsize:每個數組元素的大小/長度(單位:bytes)</li><li>nbytes: 數組的總大小(單位 bytes)</li></ul><pre class="ql-syntax">## 印出三維數組的各種屬性
print ("d3 維度(ndim): ", d3.ndim) 
print ("d3 每個維度的長度/大小(shape): ", d3.shape)
print ("d3 數組的大小長度(size): ", d3.size)
print ("d3 數組類型(dtype): ", d3.dtype)
​
print ("d3 每個數組元素的大小/長度(bytes): ", d3. itemsize, "bytes")
print ("d3 數組的總大小/長度(bytes): ", d3.nbytes, "bytes")
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">d3 維度(ndim): 3
d3 每個維度的長度/大小(shape): (2, 4, 6)
d3 數組的大小長度(size): 48
d3 數組類型(dtype): int32
d3 每個數組元素的大小/長度(bytes): 4 bytes
d3 數組的總大小/長度(bytes): 192 bytes
</pre><p>一般情況下，我們期望nbytes 等於 itemsize 乘以size ，也就是nbytes = itemsize * size</p><h3><br></h3><h3><br></h3><h2><strong>4. NumPy數組索引(Indexing)</strong></h2><h4><strong>一維數組的索引</strong></h4><pre class="ql-syntax">print (d1)
## 索引第一個元素
print (d1[0])
## 索引第七個元素
print(dl[6])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[5 8 9 5 0 0 1 7 6 9]
5
1
</pre><h4><strong>一維數組的反向索引</strong></h4><p>從數组後面來索引，使用-負號</p><pre class="ql-syntax">## 索引最後一個值
print (d1[-1])
## 索引倒數第三個值
print (d1[-3])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">9
7
</pre><h4><strong>多維數組索引</strong></h4><pre class="ql-syntax">print(d2)
​
## 索引第一個位置
print(d2[0, 0])
​
## 索引第四個元素數組裡的倒數第二個位置
print(d2[3, -2])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[[2 4 5 2 4]
 [2 4 7 7 9]
 [1 7 0 6 9]
 [9 7 6 9 1]
 [0 1 8 8 3]]
2
9
</pre><h4><br></h4><h4><strong>修改數組元素值</strong></h4><pre class="ql-syntax">## 修改第一個位置的值
d2[0, 0] = 66
d2
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[66, 4, 5, 2, 4],
   [ 2, 4, 7, 7, 9],
   [ 1, 7, 0, 6, 9],
   [ 9, 7, 6, 9, 1],
   [ 0, 1, 8, 8, 3]])
</pre><h4><br></h4><h4><strong>容易犯的錯誤</strong></h4><p>NumPy數組為固定類型的數組，與Python的動態型數組不同，當我們將浮點數類型的數據加入整數型的數組</p><p>中，它會自動技轉換成整數</p><pre class="ql-syntax">## 整数類型的一维數组中, 修改第一個位置的值為小數
d1[0] = 3.1415926
d1 ## 含自動轉成整數，因為NumPy是固定類型的數组
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([3, 8, 9, 5, 0, 0, 1, 7, 6, 9])
</pre><h3><br></h3><h3><br></h3><h2><strong>5. NumPy數組的切片(Slicing)- 獲得子數組</strong></h2><h4><strong>一維子數組 One-dimensional subarrays</strong></h4><pre class="ql-syntax">x = np. arange (10)
x
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre><ul><li>前六個元素</li></ul><pre class="ql-syntax">## 前六個元素
x[:6]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([0, 1, 2, 3, 4, 5])
</pre><ul><li>從第五個到最後一個的元素</li></ul><pre class="ql-syntax">## 從第五個到最後一個的元素
x[4:-1]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([4, 5, 6, 7, 8])
</pre><ul><li>從第三個到第八個的元素</li></ul><pre class="ql-syntax">## 從第三個到第八個的元素
x[2:8]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([2, 3, 4, 5, 6, 7])
</pre><ul><li>每隔幾個取元素</li></ul><pre class="ql-syntax">## 每隔一個取元素
print (x[::2])
## 每隔三個取元素
x[::3]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[0 2 4 6 8]
array([0, 3, 6, 9])
</pre><ul><li>每隔一個取元素，並從序號3(第四個)開始</li></ul><pre class="ql-syntax">## 每隔一個取元素，並從序號3(第四個)開始
x[3::2]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([3, 5, 7, 9])
</pre><h4><strong>一維子數組 One-dimentional subarrays的反向排序</strong></h4><pre class="ql-syntax">##反向排序
x[::-1]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
## 從序號6(第七個)開始向前取元素，每隔一個取元素
print (x[6::-2])
## 從序號8(第9個)開始向前取元素，每隔兩個取元素
x[8::-3]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[6 4 2 0]
</pre><p>Out[35]:</p><pre class="ql-syntax">array([8, 5, 2])
</pre><h4><br></h4><h4><strong>多维子數組 Multi-dimentional subarrays</strong></h4><ul><li>多维切割與一维是一樣的方式，只是加了逗號來分隔多個切劃</li></ul><pre class="ql-syntax">d2
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[66, 4, 5, 2, 4],
   [ 2, 4, 7, 7, 9],
   [ 1, 7, 0, 6, 9],
   [ 9, 7, 6, 9, 1],
   [ 0, 1, 8, 8, 3]])
</pre><ul><li>行的維度取前兩個，列的維度取前四個</li></ul><pre class="ql-syntax">## 行的維度取前兩個，列的維度取前四個
d2[:2, :4]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[66, 4, 5, 2],
   [ 2, 4, 7, 7]])
</pre><ul><li>行的维度取四個，列的維度每隔一個取元素</li></ul><pre class="ql-syntax">## 行的维度取四個，列的維度每隔一個取元素
d2 [:4, ::2]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[66, 5, 4],
   [ 2, 7, 9],
   [ 1, 0, 9],
   [ 9, 6, 1]])
</pre><ul><li>二维數組的反向排序，多維數組為一樣的概念，以此類推</li></ul><pre class="ql-syntax">## 二维數組的反向排序，多維數組為一樣的概念，以此類推
d2 [::-1, :-1]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[ 0, 1, 8, 8],
   [ 9, 7, 6, 9],
   [ 1, 7, 0, 6],
   [ 2, 4, 7, 7],
   [66, 4, 5, 2]])
</pre><ul><li>獲取數組的第幾列</li></ul><pre class="ql-syntax">## 獲取數組的第一列
print(d2[:, 0])
​
## 獲取數組的第四列
print (d2[:, 3])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[66 2 1 9 0]
[2 7 6 9 8]
</pre><ul><li>獲取數組的第幾行</li></ul><pre class="ql-syntax">## 獲取數組的第一行
print(d2[0, :])
​
## 獲取數組的第二行
print(d2[1, :1])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[66 4 5 2 4]
[2]
</pre><ul><li>獲取行的另一種寫法</li></ul><pre class="ql-syntax">## 獲取行的另一種寫法: 像是第二行 d2[1] 等同於d2[1,:]
print(d2[1])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[2 4 7 7 9]
</pre><h4><br></h4><h4><br></h4><p><strong>子數組是屬於非複製的視圖 Subarrays as no-copy views</strong></p><p><strong>重要概念:</strong></p><ul><li>Python列表的切片(list slicing)返回的是副本，也就是複製品，但是NumPy數組的切片返回的是子數组的視圖(view)而不是副本(複製品)，這也是兩者的重要差異</li><li>應用:如果我們對NumPy數組切割後的子數組進行修改，它會同時修改到整個數組</li><li>這個方法非常有用，當我們要對大數據集進行處理時，可以對其中的子數據集進行處理就好，不用到內存中再複製一份數據集出來</li></ul><p>舉個例子:我個有一個二维數組</p><pre class="ql-syntax">d2
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[66, 4, 5, 2, 4],
   [ 2, 4, 7, 7, 9],
   [ 1, 7, 0, 6, 9],
   [ 9, 7, 6, 9, 1],
   [ 0, 1, 8, 8, 3]])
</pre><p>我們切割出來一個3x3的子數組</p><pre class="ql-syntax">d2_sub = d2[:3, :3]
d2_sub
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[66, 4, 5],
   [ 2, 4, 7],
   [ 1, 7, 0]])
</pre><p>對子數組進行修改</p><pre class="ql-syntax">d2_sub[0,0] = 58
d2_sub
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[58, 4, 5],
   [ 2, 4, 7],
   [ 1, 7, 0]])
</pre><p>發現原本的二维數組也跟著修改了</p><pre class="ql-syntax">d2
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[58, 4, 5, 2, 4],
   [ 2, 4, 7, 7, 9],
   [ 1, 7, 0, 6, 9],
   [ 9, 7, 6, 9, 1],
   [ 0, 1, 8, 8, 3]])
</pre><h4><br></h4><h4><strong>創建子數組的副本(複製品)方法</strong></h4><p>有時候我們不希望修改子數組會影響到整個數組，這時候就需要複製方法</p><pre class="ql-syntax">d2
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[58, 4, 5, 2, 4],
   [ 2, 4, 7, 7, 9],
   [ 1, 7, 0, 6, 9],
   [ 9, 7, 6, 9, 1],
   [ 0, 1, 8, 8, 3]])
</pre><p>複製一個子數組出來</p><pre class="ql-syntax">## 複製一個子數組出來
d2_sub_copy = d2[:3, :3].copy()
d2_sub_copy[0, 0] = 60
d2
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[58, 4, 5, 2, 4],
   [ 2, 4, 7, 7, 9],
   [ 1, 7, 0, 6, 9],
   [ 9, 7, 6, 9, 1],
   [ 0, 1, 8, 8, 3]])
</pre><h3><br></h3><h3><br></h3><h2><strong>6. 改變數組的大小與維度 Reshaping of Arrays</strong></h2><p><br></p><p>兩種方法: reshape和newaxis</p><pre class="ql-syntax">## 將一個1到9的數組，轉為3x3的二维數組
array = np.arange(1,10)
array_new2 = array.reshape(3,3)
​
array_new2
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[1, 2, 3],
   [4, 5, 6],
   [7, 8, 9]])
</pre><p>將一個1到27的數組，轉為3x3x3的三維數組</p><pre class="ql-syntax">## 將一個1到27的數組，轉為3x3x3的三維數組
array = np.arange(1,28)
array_new = array.reshape(3,3,3)
array_new
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[[ 1, 2, 3],
   [ 4, 5, 6],
   [ 7, 8, 9]],
​
   [[10, 11, 12],
   [13, 14, 15],
   [16, 17, 18]],
​
   [[19, 20, 21],
   [22, 23, 24],
   [25, 26, 27]]])
</pre><p>reshape方法 - 行向量</p><pre class="ql-syntax">## reshape方法 - 行向量
X= np.array([1,2,3,4,5,6])
x.reshape(1,6)
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[1, 2, 3, 4, 5, 6]])
</pre><p>reshape方法 - 列向量</p><pre class="ql-syntax">## reshape方法 - 列向量
x = np.array([1,2,3,4,5,6])
x.reshape(6,1)
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[1],
   [2],
   [3],
   [4],
   [5],
   [6]])
</pre><p>newaxis方法 - 行向量</p><pre class="ql-syntax">## newaxis方法 - 行向量
x = np.array([1,2,3,4,5,6])
x[np.newaxis, :]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[1, 2, 3, 4, 5, 6]])
</pre><p>newaxis方法 - 列向量</p><pre class="ql-syntax">## newaxis方法 - 列向量
x = np.array([1,2,3,4,5,6])
x[:, np.newaxis]
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[1],
   [2],
   [3],
   [4],
   [5],
   [6]])
</pre><h3><br></h3><h3><br></h3><h2><strong>7. 數組的串聯與分割 Array Concatenation and Splitting</strong></h2><h4><br></h4><h4><strong>Concatenate 串聯</strong></h4><p><strong>串聯兩個Array</strong></p><pre class="ql-syntax">x = np.array([1,2,3,4])
y = np.array([5,6,7,8,9,10])
​
## 串聯兩個數組
np.concatenate([x, y])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
</pre><p><br></p><p><strong>串聯多個Array</strong></p><pre class="ql-syntax">z = np.array([6,12,18,28])
## 串聯三個數組
np.concatenate([x,z,y])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([ 1, 2, 3, 4, 6, 12, 18, 28, 5, 6, 7, 8, 9, 10])
</pre><p><br></p><p><strong>串聯兩個二維Array(根據第一個軸) -直的串聯</strong></p><pre class="ql-syntax">d2 = np. array([[1,2,3,4], [5,6,7,8]])
## 串聯兩個二維數組，並根據的第一個軸串聯
np.concatenate([d2, d2])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[1, 2, 3, 4],
   [5, 6, 7, 8],
   [1, 2, 3, 4],
   [5, 6, 7, 8]])
</pre><p><br></p><p><strong>串聯二維Array(根據第二個軸)- 橫的串聯</strong></p><pre class="ql-syntax">np.concatenate([d2, d2], axis = 1)
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[1, 2, 3, 4, 1, 2, 3, 4],
   [5, 6, 7, 8, 5, 6, 7, 8]])
</pre><h4><br></h4><h4><strong>hstack & vstack 水平與垂直串聯</strong></h4><p><strong>垂直串聯 vstack</strong></p><pre class="ql-syntax">x = np.array([1,2,3,4])
d2 = np.array([[5,6,7,8], [28,58,66,66]])
​
## 垂直串聯
np.vstack([x, d2])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[ 1, 2, 3, 4],
   [ 5, 6, 7, 8],
   [28, 58, 66, 66]])
</pre><p><br></p><p><strong>水平串聯hstack</strong></p><pre class="ql-syntax">y = np.array([[180], [360]])
​
## 水平串聯數組
np.hstack ([d2, y])
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[ 5, 6, 7, 8, 180],
   [ 28, 58, 66, 66, 360]])
</pre><h4><br></h4><h4><strong>補充:  np.distack 用來串聯第三軸</strong></h4><h4><br></h4><h4><br></h4><p><strong>split分割</strong></p><p><strong>split</strong></p><pre class="ql-syntax">x = [1,2,3,4,66,66,5,6,7]
​
## 根據第五個到第六個位置切成一組，並將其左右邊各切成兩組(x1,x2,x3)
x1, x2, x3 = np.split(x, [4,6]) 
print (x1, x2, x3)
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[1 2 3 4] [66 66] [5 6 7]
</pre><h4><br></h4><h4><strong>vsplit & hsplit 分割</strong></h4><pre class="ql-syntax">## 創建5x5的組
d = np.arange (25).reshape(5,5)
d
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">array([[ 0, 1, 2, 3, 4],
   [ 5, 6, 7, 8, 9],
   [10, 11, 12, 13, 14],
   [15, 16, 17, 18, 19],
   [20, 21, 22, 23, 24]])
</pre><p><br></p><p><strong>vsplit</strong></p><pre class="ql-syntax">## 垂直分割 - 根據第3行進行分割
upper, lower = np.vsplit(d, [2])
print (upper)
print (lower)
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[[0 1 2 3 4]
 [5 6 7 8 9]]
[[10 11 12 13 14]
 [15 16 17 18 19]
 [20 21 22 23 24]]
</pre><p><br></p><p><strong>hsplit</strong></p><pre class="ql-syntax">## 水平分割 - 根據第四列進行分割
left, right = np.hsplit(d, [3])
print(left)
print (right)
</pre><p><strong>執行結果</strong></p><pre class="ql-syntax">[[ 0 1 2]
 [ 5 6 7]
 [10 11 12]
 [15 16 17]
 [20 21 22]]
[[ 3 4]
 [ 8 9]
 [13 14]
 [18 19]
 [23 24]]
</pre><h4><br></h4><h4><strong>補充:np.dsplit會根據第三軸分割數組</strong></h4><p><br></p>
