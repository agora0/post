---
layout: post
title: LeetCode學習筆記 - Hash Table 雜湊表 - 觀念介紹
date: 2021-05-17 11:49:45.000000000 +00:00
link: https://matters.news/@CHWang/leet-code%25E5%25AD%25B8%25E7%25BF%2592%25E7%25AD%2586%25E8%25A8%2598-hash-table-%25E9%259B%259C%25E6%25B9%258A%25E8%25A1%25A8-%25E8%25A7%2580%25E5%25BF%25B5%25E4%25BB%258B%25E7%25B4%25B9-bafyreifaizoh35esjkurwkvrjrfiug2naz4thqqj5bri3kh46hdntkjtfe
categories: matters
tags: blog
author: 為自己Coding
---

<p><a href="https://github.com/chwang12341/LeetCode-Learning/tree/master/hash_table" target="_blank">Github連結</a></p><figure class="image">
      <picture>
        <source type="image/webp" media="(min-width: 768px)" srcset="https://assets.matters.news/processed/1080w/embed/55f1b541-9758-4d1e-9dad-d25ff6ee031b.webp" onerror="this.srcset='https://assets.matters.news/embed/55f1b541-9758-4d1e-9dad-d25ff6ee031b.jpeg'">

        <source media="(min-width: 768px)" srcset="https://assets.matters.news/processed/1080w/embed/55f1b541-9758-4d1e-9dad-d25ff6ee031b.jpeg" onerror="this.srcset='https://assets.matters.news/embed/55f1b541-9758-4d1e-9dad-d25ff6ee031b.jpeg'">

        <source type="image/webp" srcset="https://assets.matters.news/processed/540w/embed/55f1b541-9758-4d1e-9dad-d25ff6ee031b.webp">

        <img src="https://assets.matters.news/embed/55f1b541-9758-4d1e-9dad-d25ff6ee031b.jpeg" srcset="https://assets.matters.news/processed/540w/embed/55f1b541-9758-4d1e-9dad-d25ff6ee031b.jpeg" loading="lazy" referrerpolicy="no-referrer">
      </picture>
    <figcaption><span>攝影師：Jeremy Bishop，連結：Pexels</span></figcaption></figure><p><br></p><p><br></p><h2><strong>1. Hash Table 是什麼?</strong></h2><ul><li>雜湊表，又稱為哈希表</li><li>根據鍵值(Key)，並透過Hash Function來查詢在記憶體儲存位置的資料結構</li><li>其實就是一種資料儲存和訪問的技術</li><li>由成對的(key, value)所構成，在Python中，通常使用字典(Dictionary)來實現，一個Key對應一個value，不會同時有多個相同名稱的Key</li><li>主要由Keys、Hash Function和Hash Table所構成，Hash Table由N個buckets所組成，而每個bucket又由M個Slots所構成，每個Slot能夠存取一筆數據</li></ul><p><br></p><h2><strong>2. 實作過程(如下圖):</strong></h2><p>當我們要獲取Jack(<strong>Keys</strong>)的值，我們需要透過Hash Function來計算出Hashing Address(或Home Address)，然後找到 Hash Table中對應的Bucket來獲取籃球(<strong>values</strong>)</p><p><br></p><figure class="image">
      <picture>
        <source type="image/webp" media="(min-width: 768px)" srcset="https://assets.matters.news/processed/1080w/embed/2e178023-5650-4453-8199-bbb80a1e5a91.webp" onerror="this.srcset='https://assets.matters.news/embed/2e178023-5650-4453-8199-bbb80a1e5a91.png'">

        <source media="(min-width: 768px)" srcset="https://assets.matters.news/processed/1080w/embed/2e178023-5650-4453-8199-bbb80a1e5a91.png" onerror="this.srcset='https://assets.matters.news/embed/2e178023-5650-4453-8199-bbb80a1e5a91.png'">

        <source type="image/webp" srcset="https://assets.matters.news/processed/540w/embed/2e178023-5650-4453-8199-bbb80a1e5a91.webp">

        <img src="https://assets.matters.news/embed/2e178023-5650-4453-8199-bbb80a1e5a91.png" srcset="https://assets.matters.news/processed/540w/embed/2e178023-5650-4453-8199-bbb80a1e5a91.png" loading="lazy" referrerpolicy="no-referrer">
      </picture>
    <figcaption><span></span></figcaption></figure><p><br></p><p><br></p><h2><strong>3. Hash Table的優勢</strong></h2><ul><li><strong>主要優點: 執行insert/search/delete/modify的時間複雜度皆為O(1)，也就是不管資料量多大都超級快</strong></li></ul><p>(<strong>但當Hash Collision發生時，上面的優點不成立</strong>)</p><ul><li>Data與排列順序並沒有什麼關係，所以搜尋數據時，不需要事先排序</li><li>由於中間有Hash Function，不瞭解它做了什麼運算，很難取得Data，所以安全性和保密性非常高</li></ul><h2><br></h2><h2><strong>4. Hash Table 應用範圍</strong></h2><ul><li>數據本身與其排列順序並無關係</li><li>沒有重複訪問值的情況(ex. Jack就是對應籃球)</li><li>或重複情況下需要統計次數的時候，像是今天Jack可能從體育室拿了好幾次籃球，我們要去統計他拿了幾次</li><li>需要在O(1)的時間複雜度下快速地存取DATA時</li></ul><p><br></p><p><br></p><h2><strong>5. Hash Collision是什麼?</strong></h2><p>不同筆數據，像是(a, b)，經過中間Hash Function的計算後，得到了一樣的Hashing Address，就是H(a) = H(b)</p><h2><br></h2><h2><strong>6. Python中如何操作Dictionary</strong></h2><ul><li>創建字典: {} 或 dict()</li></ul><pre class="ql-syntax">## 創立字典
python_dict = {'x': 1, 'y': 4}
python_dict
{'x': 1, 'y': 4}
</pre><ul><li>插入:</li></ul><pre class="ql-syntax">## 插入新數據
python_dict['z'] = 10
python_dict
{'x': 1, 'y': 4, 'z': 10}
</pre><ul><li>訪問值:</li></ul><pre class="ql-syntax">## 訪問數據
print(python_dict.get('z'))
print(python_dict['z'])
10
10
</pre><ul><li>刪除:</li></ul><pre class="ql-syntax">## 刪除一組數據
del python_dict['z']
python_dict
{'x': 1, 'y': 4}
</pre><ul><li>判斷字典中是否存在某key</li></ul><pre class="ql-syntax">## 第一種方法
print(python_dict.__contains__('z'))
## 第二種方法
print('x' in python_dict)
False
True
</pre><ul><li>取得一組一組的key和value: for k, v in python_dict.items():</li></ul><pre class="ql-syntax">## 取得一組一組的key和value
for k, v in python_dict.items():
  print(k)
  print(v)
x
1
y
4
</pre><h2><br></h2><h2><br></h2><h2><strong>Reference</strong></h2><p><strong>由於這篇是參考我所學習的課程加上網路資源，再經過自己的消化而來，如果有地方原作者覺得不妥，都請馬上與我聯繫喔，我會馬上移除，感謝</strong></p><p><a href="https://hiskio.com/courses/319/lectures/15376" target="_blank">https://hiskio.com/courses/319/lectures/15376</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank">https://zh.wikipedia.org/wiki/哈希表</a></p><p><a href="https://blog.kennycoder.io/2020/02/18/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Hashing-%E9%9B%9C%E6%B9%8A%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9/" target="_blank">https://blog.kennycoder.io/2020/02/18/資料結構與演算法筆記-Hashing-雜湊原理介紹/</a></p><p><br></p>
